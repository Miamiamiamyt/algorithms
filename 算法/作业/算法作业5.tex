\documentclass[19pt,a4paper]{article}
\usepackage{xeCJK}
\usepackage{amsmath}
\setmainfont{STSong}
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\setlength{\parindent}{4em}
\usepackage{graphicx}
\title{算法作业5}
\author{孟妍廷2015202009}
\date{2017年10月22日}  

\begin{document}
\maketitle

8.3-2\\
\indent \ \ \ \ 解：插入排序是稳定的，因为它是从某一位置起依次向前比较，不会改变两个相同元素的相对\\
\indent 位置。归并排序也是稳定的，因为它递归的过程中每次将当前数组分为两半，直到分成单个元\\
\indent 素，最后进行比较和合并，不改变两个相同元素的相对位置。堆排序是不稳定的，因为它不能\\
\indent 保证分别位于完全二叉树的左右子树的两个相同元素的相对位置不被改变。快速排序也是不稳\\
\indent 定的，因为partition过程中若有元素与主元相等，他们的相对位置可能会被改变。\\
\indent 使任何排序算法都稳定的算法(假设被排序的数组为A,长度为n): \\
\indent 加入一个长度为n的数组B[n],记录原数组中每个元素最初的位置,即B[i]=i.在排序过程中,\\
\indent 在每次出现swap(A[i],A[j])时同时执行 swap(B[i],B[j]).由于排序后相同的元素是连在一起的,\\
\indent 在所有排序后加上:
$$for \ i=1\ to\ n$$
$$while(A[i]==A[i+1])$$
$$count++;$$
$$根据B[i]到B[i+count]的大小对A[i]到A[i+count]进行排序$$
\indent 由于在排序中，相同的元素应该是常数个，否则排序失去意义，没有增加额外的时间开销，\\
\indent 额外的空间开销为O(n).
\\
\\
\indent 8.2\\
\indent 解:对于题目中的关键字的值为0或1的 理解:待排序的数组的元素值为0或1\\
\\
\indent a.要求算法满足时间复杂度为O(n)且是稳定的,则计数算法满足要求\\
\indent 因为计数算法是稳定的,且取值只有0和1,所以k为2,远远小于n,故时间复杂度为O(n)\\
\\
\indent b.要求算法时间复杂度为O(n)且是原址排序，只需要固定的额外存储空间\\
\indent 修改快速排序中的partition函数如下:
$$partition(A,p,r)$$
$$i\ = \ p-1$$
$$for\ j\ =\ p\ to\ r$$
$$if\ A[j]\ ==\ 0$$
$$i\ =\ i+1$$
$$swap(A[i],A[j])$$
\indent 满足要求,排序后数组左边为为0的元素,右边为为1的元素\\
\\
\indent c.要求算法是稳定的且是原址排序，只需要固定的额外的存储空间\\
\indent 插入排序满足要求,只是时间复杂度不为O(n).
\\
\indent d.算法(a),即计数排序可以使基数排序的时间代价是O(bn)\\
\indent 由于计数排序是稳定的,且k=2,故由引理8.3可证。(题目中的如何处理是什么意思?)\\
\indent 而算法(b)不是稳定的,算法(c)的时间复杂度不是O(n).\\
\\
\indent e.依题意修改计数排序算法如下:\\
\indent $counting\_sort(A,k)$\\
\indent $let\ C[0....k]\ be\ a\ new\ array$\\
\indent $for\ i\ =\ 0\ to\ k$\\
\indent \ \ \ \ $C[i]\ =\ 0$\\
\indent $for\ j\ =\ 1\ to\ A.length$\\
\indent \ \ \ \ $C[A[j]]\ =\ C[A[j]]+1$\\
\indent $for\ i\ =\ 1\ to\ k$\\
\indent \ \ \ \ $C[i]\ =\ C[i]+C[i-1]$\\
\indent $i\ =\ 1$\\
\indent $while\ i\ <\ C.length$\\
\indent \ \ \ \ $for\ j\ =\ C[i-1]\ to\ C[i]-1$\\
\indent \ \ \ \ \ \ \ \ $A[j]=i$\\
\indent\ \ \ \ $i++$\\
\indent 由于该算法相当于统计出每个元素应该在的位置,把原数组覆盖掉\\
\indent 所以该算法可以在O(n+k)时间内实现对n条记录的原址排序,但是该算法不稳定\\
\\
\\
\indent 9.3-1\\
\indent 证明：\\
\indent \ \ \ \ 假设每组x个元素(x为奇数),则除了n不能整除x时产生的元素少于x个的组和包含\\
\indent x的组之外，至少有一半的组中有$\lceil\frac{x}{2}\rceil$个元素大于x,则大于x的元素个数至少为:
$$\lceil\frac{x}{2}\rceil(\lceil\frac{1}{2}\lceil\frac{n}{x}\rceil\rceil-2)\ge\frac{n}{4}-x$$
\indent 所以只有当所有小于x的数都被遍历时达到最坏情况,最多有$\frac{3}{4}n+x$个\\
\indent 则在最坏情况下的递归式为:
$$T(n)=T(\lceil\frac{n}{x}\rceil)+T(\frac{3}{4}n+x)+O(n)$$
$$\le\frac{cn}{x}+c+\frac{3}{4}cn+cx+an$$
$$=(\frac{1}{x}+\frac{3}{4})cn+cx+c+an$$
$$=cn-\frac{x-4}{4x}cn+cx+c+an\ \ \ \ \ (*)$$
\indent 可知若要上式满足$(*)<O(n)$,需满足$x-4>0$即$x>4$,否则时间复杂度>O(n)\\
\indent 因此每组7个元素时仍然是线性时间，每组3个元素时SELECT的运行时间不是线性时间。






\end{document}